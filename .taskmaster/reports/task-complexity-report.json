{
	"meta": {
		"generatedAt": "2025-08-12T17:13:36.962Z",
		"tasksAnalyzed": 2,
		"totalTasks": 23,
		"analysisCount": 2,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": false
	},
	"complexityAnalysis": [
		{
			"taskId": 6,
			"taskTitle": "Homepage and Static Pages Development",
			"complexityScore": 4,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Based on the analysis of the existing component library (Task 3) and data models (Task 2), expand this task into subtasks for creating the main static pages. The existing `app/schedule/page.tsx` should serve as a reference for page structure and data fetching. The subtasks should cover:\n1.  **Homepage Shell and Hero Section:** Create `app/page.tsx` and implement the main layout with a hero section, using a video or an optimized Next.js Image component.\n2.  **Homepage Content Sections:** Populate the homepage with a 'Featured Offerings' section by fetching data from the `Class` or `Retreat` models, a 'Testimonials' section (using static data for now), and a stubbed-out 'Newsletter Signup' form.\n3.  **About/Philosophy Page:** Create `app/about/page.tsx` and populate it with static content and images, reusing components like `Card` for layout.\n4.  **Instructor Bio Page(s):** Create a dynamic route `app/instructors/[slug]/page.tsx` that fetches and displays data for a specific instructor from the `User` model.\n5.  **Responsive Polish and Link Integration:** Conduct a full review of all new pages across desktop, tablet, and mobile breakpoints. Ensure all navigation links and Calls-to-Action (CTAs) are correctly wired up.",
			"reasoning": "Complexity is rated 4/10. The codebase analysis confirms that foundational elements are complete and robust. Task 3 provided a reusable component library (`Button`, `Card`, `Navbar`), and Task 2 established the necessary Prisma data models (`User`, `Class`). The `Class Schedule` page (Task 7) offers a clear pattern for server-side data fetching and page composition. This task is therefore primarily about assembling existing components and content, rather than complex greenfield development. The main effort lies in layout composition and content integration, which is straightforward."
		},
		{
			"taskId": 22,
			"taskTitle": "Refactor Auth Tests for Maintainability and Clarity",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Based on the analysis of the auth test suite in `tests/auth/`, expand this refactoring task. The `grep` results confirm duplicated Prisma mock initializations and manual `node-mocks-http` setups across multiple files (e.g., `logout.test.ts`). The subtasks should follow the detailed plan:\n1.  **Centralize Prisma Mock:** Create a single `tests/lib/prismaMock.ts` file to export a singleton instance of the `jest-mock-extended` Prisma client. Update `jest.config.js` to include this via `setupFilesAfterEnv`. Refactor all files in `tests/auth/` to remove local mock declarations and import the singleton instead.\n2.  **Create and Integrate API Request Helper:** Implement a generic `testApiHandler(handler, options)` function in a new `tests/lib/apiHelper.ts` file. This helper will encapsulate `node-mocks-http` logic. Systematically replace all manual `createMocks` calls in the auth tests with this new, streamlined helper.\n3.  **Standardize Console Noise Suppression:** Audit all auth tests for expected `console.error` or `console.warn` calls (e.g., during 401/403 error tests). Apply `jest.spyOn(console, 'error').mockImplementation(() => {})` within specific `it` blocks where logging is expected, ensuring `jest.restoreAllMocks()` is called in an `afterEach` block to maintain test isolation.",
			"reasoning": "Complexity is rated 5/10. This is a medium-complexity refactoring task. It doesn't involve creating new features, but it requires careful and systematic changes across the entire authentication test suite. Analysis of files like `tests/auth/logout.test.ts` confirms the presence of boilerplate code for mocking Prisma and creating API requests, as described in the task. The complexity comes from the breadth of the changes and the need to ensure the entire suite remains functional after the refactor. The steps are well-defined, but the implementation requires precision to avoid introducing regressions."
		}
	]
}